(window.webpackJsonp=window.webpackJsonp||[]).push([[284],{714:function(n,e,o){"use strict";o.r(e);var s=o(29),t=Object(s.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("p",[n._v("在近期的Vue开发中，使用了大量的ES6语法，因此觉得有必要找个时间来整理下近期的学习笔记。ES6相对ES5增加了许多新的特性，给我们的开发提供了方便。并且ES6也是未来开发的潮流，所以我觉得大家很有必要去掌握这一技能。\n")]),n._v(" "),o("p",[n._v("在我们正式学习ES6前，我们需要先去学习下转码器。常用的转码器有"),o("a",{attrs:{href:"https://link.jianshu.com?t=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fsetup%2F",target:"_blank",rel:"noreferrer noopener"}},[n._v("Babel")]),n._v("和Traceur。这里推荐一篇"),o("a",{attrs:{href:"https://link.jianshu.com?t=https%3A%2F%2Fwww.cnblogs.com%2Fyufann%2Fp%2FES6-note1.html",target:"_blank",rel:"noreferrer noopener"}},[n._v("常见的ES6转码工具")]),n._v("有兴趣的可以去看看。\n")]),n._v(" "),o("p",[n._v("接下来我们就一起去见证ES6的神奇之处吧！\n")]),n._v(" "),o("p",[n._v("##1.let和const\n")]),n._v(" "),o("p",[n._v("let与var类似是用来声明变量的，const用来声明常量。在实际用途中它们存在着许多区别，废话不多说，直接看代码。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("  {\n      var a = 100;\n      let b = 200;\n  }\n  console.log(a); //100\n  console.log(b); //b is not defined -- Error\n")])]),n._v(" "),o("p",[n._v("是不是感觉很奇怪，为什么a有值而b却not defined呢？因为ES5只有全局作用域和函数作用域，没有块级作用域。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。\n")]),n._v(" "),o("p",[n._v("let不存在变量提升。那么什么是变量提升呢？简单来说就是无论声明在什么地方，都会被视为声明在顶部。下面来看个例子。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v('//ES5\n    console.log("ES5:");\n    var a = [];\n    for (var i = 0; i < 10; i++) {\n        var c = i;\n        a[i] = function () {\n            console.log(c);\n        };\n    };\n    a[5](); //结果:9\n')])]),n._v(" "),o("p",[n._v("是不是有许多小伙伴在疑惑为什么输出的不是5呢？变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v('//ES6\n    console.log("ES6:");\n    var b = [];\n    for (var j = 0; j < 10; j++) {\n        let d = j;\n        b[j] = function () {\n            console.log(d);\n        };\n    };\n    b[5](); 结果://5\n')])]),n._v(" "),o("p",[n._v("同时let也是不允许重复声明的。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("    {\n        var a = 100;\n        var a = 200;\n        console.log(a); //200\n    }\n    // 模块内部不允许用let命令重复声明\n    {\n        var a = 1;\n        let a = 2;\n        console.log(a); // 报错\n    }\n")])]),n._v(" "),o("p",[n._v("下面再来说说 const。const也用来声明变量，但是声明的是常量，一旦声明，常量的值就不能改变。它和let一样只在声明的区域内有用。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("    {\n        var a   = 100;\n        const a = 200;\n        console.log(a); // 报错\n    }\n")])]),n._v(" "),o("p",[n._v("const声明对象\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v('    const person = {};\n    person.name  = "Zhangsan";\n    person.age   = 30;\n\n    console.log(person.name);   //Zhangsan\n    console.log(person.age);    //30\n    console.log(person);        //Object {name: "Zhangsan", age: 30}\n')])]),n._v(" "),o("p",[n._v("const对象冻结\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v('    const person = Object.freeze({});\n    person.name  = "Zhangsan";\n    person.age   = 30;\n\n    console.log(person.name);   //undefined\n    console.log(person.age);    //undefined\n    console.log(person);        //Object\n')])]),n._v(" "),o("p",[n._v("##2.模板字符串\n")]),n._v(" "),o("p",[n._v("相对于es5的' '+变量这种字符串拼接方法，es6的模板字符串要方便许多。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("     var a = '张三';\n     var age = 18;\n     var b = '我的名字是'+a+'我今年'+age+'岁了'; // es5\n     var c = `我的名字是${a}我今年${age}岁了`; // es6\n")])]),n._v(" "),o("p",[n._v("当然简单的两行代码可能它的优势没有那么的明显，一旦代码量变多，你就能体会到它的便利了。\n")]),n._v(" "),o("p",[n._v("##3.函数\n")]),n._v(" "),o("p",[n._v("#####函数默认参数\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("     function num(n) {\n        n = n '' 200; //当传入n时，n为传入的值，没有则默认200\n        return n;\n     }\n")])]),n._v(" "),o("p",[n._v("es6为参数提供了默认值。在定义函数时便初始化了这个参数，直接看代码。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("     function num(n = 200) {\n        return n;\n     }\n     console.log(n()); // 200\n     console.log(n(100)); // 100\n")])]),n._v(" "),o("p",[n._v("#####箭头函数\n")]),n._v(" "),o("p",[n._v("箭头函数的基本用法。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("// es5\n     function breakfast(dessert,drink){\n        return dessert+drink;\n     }\n// es6\n     let breakfast = (dessert,drink) => dessert + ' ' + drink;\n     console.log(breakfast('面包','牛奶'));\n")])]),n._v(" "),o("p",[n._v("箭头函数的this指向绑定定义是所在的作用域，而普通函数this指向运行时所在的作用域（全局对象），箭头函数没有自己的this而是引用外层的this。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v('// es5\n     cartView: function() {\n          var _this = this;\n          this.$http.get("data/cartData.json", {"id": 123}).then(function(res) {\n              _this.productList = res.data.result.list;\n              console.log(_this.productList);\n        });\n      }\n// es6\n      cartView(){\n          this.$http.get("data/cartData.json", {"id": 123}).then((res) {\n              this.productList = res.data.result.list;\n              console.log(this.productList);\n        });\n      }\n')])]),n._v(" "),o("p",[n._v("##4.解构\n")]),n._v(" "),o("p",[n._v("数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("// es5提取对象\n    let people = {\n        name : 'json',\n        age : 18,\n        sex : 'male'\n    }；\n    let name = people.name;\n    let age = people.age;\n    ...\n // es6\n    let people = {\n        name : 'json',\n        age : 18,\n        sex : 'male'\n    }；\n    let {name, age, sex} = people;\n")])]),n._v(" "),o("p",[n._v("相比于es5是不是简便了许多，当然数组的方法与对象的类似。下面我们再来举个栗子，函数参数解构赋值的默认值。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("    fun ({x, y} = { x: 0, y: 0 }) {\n        return [x, y];\n    };\n\n    console.log(fun({x: 100, y: 200})); //[100, 200]\n    console.log(fun({x: 100}));         //[100, undefined]\n    console.log(fun({}));               //[undefined, undefined]\n    console.log(fun());                 //[0, 0]\n")])]),n._v(" "),o("p",[n._v("讲了这么多，可能有人就会问了这个解构到底有什么用呢？其实它适合于各种与数组，对象，函数打交道的场景。下面我们来举个运用最广的例子-变量交换。直接上代码。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v('//ES5\n    console.log("ES5:");\n    var a = 100;\n    var b = 200;\n    console.log("交换前：");\n    console.log("a = " + a);    //a = 100\n    console.log("b = " + b);    //b = 200\n    var temp;\n    temp = a;\n    a = b;\n    b = temp;\n    console.log("交换后：");\n    console.log("a = " + a);    //a = 200\n    console.log("b = " + b);    //b = 100\n\n    //ES6\n    console.log("ES6:");\n    var x = 100;\n    var y = 200;\n    console.log("交换前：");\n    console.log("x = " + x);    //x = 100\n    console.log("y = " + y);    //y = 200\n    ')])]),n._v(" "),o("p",[n._v("[x, y]\n")]),n._v(" "),o("p",[n._v('= [y, x];\nconsole.log("交换后：");\nconsole.log("x = " + x);    //x = 200\nconsole.log("y = " + y);    //y = 100\n')]),n._v(" "),o("p",[n._v("##5. ...操作符\n")]),n._v(" "),o("ul",[o("li",[n._v("展开操作符\n")])]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("    let str2 = ['苹果','梨子'];\n    console.log(str2);//[\"苹果\", \"梨子\"]\n    console.log(...str2);//苹果 梨子\n")])]),n._v(" "),o("ul",[o("li",[n._v("剩余操作符\n")])]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("    fun(a,b,...c){\n        console.log(a,b,...c);//...c指展开数组\n    }\n    fun('苹果','香蕉','橘子','梨子','李子');//苹果 香蕉 橘子 梨子 李子\n")])]),n._v(" "),o("p",[n._v("##6.class、 extends、 super\n")]),n._v(" "),o("p",[n._v("这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承...看到它们是不是开始怀疑人生了。\n")]),n._v(" "),o("p",[n._v("别怕有来了ES6我们以后再怀疑吧！\n")]),n._v(" "),o("p",[n._v("ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("class MyClass {\n  constructor() {  // 构造函数\n    // ...\n  }\n  get prop() {  // 取值\n    return 'getter';\n  }\n  set prop(value) { // 存值\n    console.log('setter: '+value);\n  }\n}\n\nlet inst = new MyClass();\ninst.prop = 123;\n// setter: 123\nconsole.log(inst.prop);\n// 'getter'\n")])]),n._v(" "),o("p",[n._v("extends用法\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n")])]),n._v(" "),o("p",[n._v("在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。父类的静态方法，也会被子类继承。\n")]),n._v(" "),o("p",[n._v("注意，super虽然代表了父类Point的构造函数，但是返回的是子类ColorPoint的实例，即super内部的this指的是ColorPoint，因此super()在这里相当于Point.prototype.constructor.call(this)。\n")]),n._v(" "),o("p",[n._v("super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。"),o("br"),n._v("\n作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("    class A {}\n    class B extends A {\n      m() {\n         super(); // 报错\n      }\n    }\n")])]),n._v(" "),o("p",[n._v("第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("     class A {\n           p() {\n            return 2;\n          }\n        }\n     class B extends A {\n            constructor() {\n            super();\n            console.log(super.p()); // 2\n          }\n        }\n        let b = new B();\n")])]),n._v(" "),o("p",[n._v("上面代码中，子类B当中的super.p()就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。\n")]),n._v(" "),o("p",[n._v("##7.Promise\n")]),n._v(" "),o("p",[n._v("在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("this.$http('/api/getData').then((res) => {\nres = res.data;\nthis.dataList = res.result;\n}).catch((err) => {\n...\n});\n")])]),n._v(" "),o("p",[n._v("这是一个vue的异步请求，用的就是promise机制，这样的好处是不会因为多层的回调而降低代码的可读性。\n")]),n._v(" "),o("p",[n._v("当然这只是promise的冰山一角，想要更好的掌握它还是需要更加深入的去学习它。\n")]),n._v(" "),o("p",[n._v("##8.Set\n")]),n._v(" "),o("p",[n._v("实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n")]),n._v(" "),o("ul",[o("li",[n._v("操作方法："),o("br"),n._v("\nadd(value)：添加某个值，返回Set结构本身。"),o("br"),n._v("\ndelete(value)：删除某个值，返回一个布尔值，表示删除是否成功。"),o("br"),n._v("\nhas(value)：返回一个布尔值，表示该值是否为Set的成员。"),o("br"),n._v("\nclear()：清除所有成员，没有返回值。* 遍历方法："),o("br"),n._v("\nkeys()：返回键名的遍历器"),o("br"),n._v("\nvalues()：返回键值的遍历器"),o("br"),n._v("\nentries()：返回键值对的遍历器"),o("br"),n._v("\nforEach()：使用回调函数遍历每个成员"),o("br"),n._v("\n由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值）\n")])]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("let str = [1,2,3,2,4,3,5,6,4,1,7];\nconsole.log('str的长度为：'+str.length); // 长度为11\nlet s = new Set(str);\nconsole.log(s);\nconsole.log('去重后的长度为：'+s.size);//长度为7\nconsole.log( Array.from(s));//Array.from 将Set转换为数组形式\n\nlet set = new Set(['red', 'green', 'blue']);\nvar arr = new Set();\nfor (let item of set.keys()) {\n  console.log(item);// red green blue\n  arr.add(item);//将item添加到arr set结构中\n}\nconsole.log(arr);\narr.forEach((value, key) => console.log(key + ' : ' + value));\n")])]),n._v(" "),o("p",[n._v("##9.import 和 export\n")]),n._v(" "),o("pre",{staticClass:"wp-block-code"},[o("code",[n._v("//全部导入\nimport mallHeader from '../components/header.vue'\n//导入部分\nimport {name, age} from './example'\n// 导出默认, 有且只有一个默认\nexport default App\n// 部分导出\nexport class App extend Component {};\n\n")])]),n._v(" "),o("p",[n._v("##小结\n")]),n._v(" "),o("p",[n._v("这些仅仅是es6家族中的冰山一角，想要更加全面的去掌握这一技能，就需要我们更加系统的去学习它。感谢花了这么长时间，阅读文章的小伙伴们，希望能对你们带来帮助。有错误的地方希望大佬们多多包涵，给我反馈！\n")]),n._v(" "),o("p",[n._v("链接：https://www.jianshu.com/p/342ae4b2ef99\n")])])}),[],!1,null,null,null);e.default=t.exports}}]);
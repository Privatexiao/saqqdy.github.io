(window.webpackJsonp=window.webpackJsonp||[]).push([[322],{752:function(n,e,t){"use strict";t.r(e);var s=t(29),a=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("前端是一个近几年非常流行的新技术岗位，前端工程师的出现实现了设计、展现、业务的彻底分离，今天要讲的JS设计模式，正是一个高级前端工程师必须要了解的前端开发方式。\n")]),n._v(" "),t("h3",{attrs:{id:"articleHeader1"}},[n._v("发布订阅模式（观察者模式）:")]),n._v(" "),t("p",[n._v("这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护，也就是说，这种模式就是用一大串的列表来维护多对多的关系。\n")]),n._v(" "),t("pre",{staticClass:"wp-block-code"},[t("code",[n._v("// 一个播放器类\nclass Player {\n  constructor() {\n    // 初始化观察者列表\n    this.watchers = {}\n\n    // 模拟2秒后发布一个'play'事件\n    setTimeout(() => {\n      this._publish('play', true)\n    }, 2000)\n\n    // 模拟4秒后发布一个'pause'事件\n    setTimeout(() => {\n      this._publish('pause', true)\n    }, 4000)\n  }\n\n  // 发布事件\n  _publish(event, data) {\n    if (this.watchers[event] && this.watchers[event].length) {\n      this.watchers[event].forEach(callback => callback.bind(this)(data))\n    }\n  }\n\n  // 订阅事件\n  subscribe(event, callback) {\n    this.watchers[event] = this.watchers[event] '' []\n    this.watchers[event].push(callback)\n  }\n\n  // 退订事件\n  unsubscribe(event = null, callback = null) {\n    // 如果传入指定事件函数，则仅退订此事件函数\n    if (callback&&event) {\n      if (this.watchers[event] && this.watchers[event].length) {\n        this.watchers[event].splice(this.watchers[event].findIndex(cb => Object.is(cb, callback)), 1)\n      }\n\n    // 如果仅传入事件名称，则退订此事件对应的所有的事件函数\n    } else if (event) {\n      this.watchers[event] = []\n\n    // 如果未传入任何参数，则退订所有事件\n    } else {\n      this.watchers = {}\n    }\n  }\n}\n\n// 实例化播放器\nconst player = new Player()\nconsole.log(player)\n\n// 播放事件回调函数1\nconst onPlayerPlay1 = data => {\n  console.log('1: Player is play, the `this` context is current player', this, data)\n}\n\n// 播放事件回调函数2\nconst onPlayerPlay2 = data => {\n  console.log('2: Player is play', data)\n}\n\n// 暂停事件回调函数\nconst onPlayerPause = data => {\n  console.log('Player is pause', data)\n}\n\n// 加载事件回调函数\nconst onPlayerLoaded = data => {\n  console.log('Player is loaded', data)\n}\n\n// 可订阅多个不同事件\nplayer.subscribe('play', onPlayerPlay1)\nplayer.subscribe('play', onPlayerPlay2)\nplayer.subscribe('pause', onPlayerPause)\nplayer.subscribe('loaded', onPlayerLoaded)\n\n// 可以退订指定订阅事件\nplayer.unsubscribe('play', onPlayerPlay2)\n// 退订指定事件名称下的所有订阅事件\nplayer.unsubscribe('play')\n// 退订所有订阅事件\nplayer.unsubscribe()\n\n// 可以在外部手动发出事件（真实生产场景中，发布特性一般为类内部私有方法）\nplayer._publish('loaded', true)")])]),n._v(" "),t("h3",{attrs:{id:"articleHeader2"}},[n._v("中介者模式 Mediator Pattern:")]),n._v(" "),t("p",[n._v("观察者模式通过维护一堆列表来管理对象间的多对多关系，中介者模式通过统一接口来维护一对多关系，且通信者之间不需要知道彼此之间的关系，只需要约定好API即可。\n")]),n._v(" "),t("pre",{staticClass:"wp-block-code"},[t("code",[n._v("// 汽车\nclass Bus {\n  constructor() {\n    // 初始化所有乘客\n    this.passengers = {}\n  }\n\n  // 发布广播\n  broadcast(passenger, message = passenger) {\n    // 如果车上有乘客\n    if (Object.keys(this.passengers).length) {\n      // 如果是针对某个乘客发的，就单独给他听\n      if (passenger.id && passenger.listen) {\n        // 乘客他爱听不听\n        if (this.passengers[passenger.id]) {\n          this.passengers[passenger.id].listen(message)\n        }\n      // 不然就广播给所有乘客\n      } else {\n        Object.keys(this.passengers).forEach(passenger => {\n          if (this.passengers[passenger].listen) {\n            this.passengers[passenger].listen(message)\n          }\n        })\n      }\n    }\n  }\n\n  // 乘客上车\n  aboard(passenger) {\n    this.passengers[passenger.id] = passenger\n  }\n\n  // 乘客下车\n  debus(passenger) {\n    this.passengers[passenger.id] = null\n    delete this.passengers[passenger.id]\n    console.log(`乘客${passenger.id}下车`)\n  }\n\n  // 开车\n  start() {\n    this.broadcast({ type: 1, content: '前方无障碍，开车！Over'})\n  }\n\n  // 停车\n  end() {\n    this.broadcast({ type: 2, content: '老司机翻车，停车！Over'})\n  }\n}\n\n// 乘客\nclass Passenger {\n  constructor(id) {\n    this.id = id\n  }\n  // 听广播\n  listen(message) {\n    console.log(`乘客${this.id}收到消息`, message)\n    // 乘客发现停车了，于是自己下车\n    if (Object.is(message.type, 2)) {\n      this.debus()\n    }\n  }\n  // 下车\n  debus() {\n    console.log(`我是乘客${this.id}，我现在要下车`, bus)\n    bus.debus(this)\n  }\n}\n\n// 创建一辆汽车\nconst bus = new Bus()\n\n// 创建两个乘客\nconst passenger1 = new Passenger(1)\nconst passenger2 = new Passenger(2)\n\n// 俩乘客分别上车\nbus.aboard(passenger1)\nbus.aboard(passenger2)\n\n// 2秒后开车\nsetTimeout(bus.start.bind(bus), 2000)\n\n// 3秒时司机发现2号乘客没买票，2号乘客被驱逐下车\nsetTimeout(() => {\n  bus.broadcast(passenger2, { type: 3, content: '同志你好，你没买票，请下车!' })\n  bus.debus(passenger2)\n}, 3000)\n\n// 4秒后到站停车\nsetTimeout(bus.end.bind(bus), 3600)\n\n// 6秒后再开车，车上已经没乘客了\nsetTimeout(bus.start.bind(bus), 6666)")])]),n._v(" "),t("h3",{attrs:{id:"articleHeader3"}},[n._v("代理模式 Proxy Pattern:")]),n._v(" "),t("blockquote",{staticClass:"wp-block-quote"},[n._v("为其他对象提供一种代理以控制对这个对象的访问。"),t("br"),n._v("代理模式使得代理对象控制具体对象的引用。代理几乎可以是任何对象：文件，资源，内存中的对象，或者是一些难以复制的东西。")]),n._v(" "),t("p",[n._v("ES6中的Proxy对象\n")]),n._v(" "),t("pre",{staticClass:"wp-block-code"},[t("code",[n._v('const target = {}\nconst handler = {\n    get(target, property) {\n        if (property in target) {\n            return target[property]\n        } else {\n            throw new ReferenceError("Property \\"" + property + "\\" does not exist.")\n        }\n    }\n}\nconst p = new Proxy(target, {})\np.a = 3  // 被转发到代理的操作\nconsole.log(p.c) //')])]),n._v(" "),t("h3",{attrs:{id:"articleHeader4"}},[n._v("单例模式 Singleton Pattern:")]),n._v(" "),t("blockquote",{staticClass:"wp-block-quote"},[n._v("保证一个类只有一个实例，并提供一个访问它的全局访问点（调用一个类，任何时候返回的都是同一个实例）。")]),n._v(" "),t("p",[n._v("实现方法：使用一个变量来标志当前是否已经为某个类创建过对象，如果创建了，则在下一次获取该类的实例时，直接返回之前创建的对象，否则就创建一个对象。\n")]),n._v(" "),t("pre",{staticClass:"wp-block-code"},[t("code",[n._v("// 类数实例：\nclass Singleton {\n  constructor(name) {\n    this.name = name\n    this.instance = null   // \n  }\n  getName() {\n    alert(this.name)\n  }\n  static getInstance(name) {\n    if (!this.instance) {\n      this.instance = new Singleton(name)\n    }\n    return this.instance\n  }\n}\nconst ins = new Singleton('hhhh')\nconst instanceA = Singleton.getInstance('seven1')\nconst instanceB = Singleton.getInstance('seven2')\n//闭包包装实例：\nconst SingletonP = (function() {\n  let instance\n  return class Singleton {\n\n    constructor(name) {\n      if (instance) {\n        return instance\n      } else {\n        this.init(name)\n        instance = this\n        return this\n      }\n    }\n\n    init(name) {\n      this.name = name\n      console.log('已初始化')\n    }\n  }\n})()\n\nconst instanceA = new SingletonP('seven1')\nconst instanceB = new SingletonP('seven2')\n// ES5 iife\nvar SingletonTester = (function () {\n    function Singleton(args) {\n        var args = args '' {};\n        //设置name参数\n        this.name = 'SingletonTester';\n    }\n    //实例容器\n    var instance;\n    return {\n        name: 'SingletonTester',\n        getInstance: function (args) {\n            if (instance === undefined) {\n                instance = new Singleton(args);\n            }\n            return instance;\n        }\n    };\n})();\n\nvar singletonTest = SingletonTester.getInstance({ pointX: 5 });\nconsole.log(singletonTest.pointX); // 输出 5 \n// 构造函数的属性\nfunction Universe() {\n    if (typeof Universe.instance === 'object') {\n        return Universe.instance;\n    }\n    this.start_time = 0;\n    this.bang = \"Big\";\n    Universe.instance = this;\n}\n// 测试\nvar uni = new Universe();\nvar uni2 = new Universe();\nconsole.log(uni === uni2); // true\n// 重写构造函数\nfunction Universe() {\n    var instance = this;\n    // 其它内容\n    this.start_time = 0;\n    this.bang = \"Big\";\n    // 重写构造函数\n    Universe = function () {\n        return instance;\n    };\n}\n// 测试\nvar uni = new Universe();\nvar uni2 = new Universe();\nuni.bang = \"123\";\nconsole.log(uni === uni2); // true\nconsole.log(uni2.bang); // 123")])]),n._v(" "),t("h3",{attrs:{id:"articleHeader5"}},[n._v("工厂模式 Factory Pattern:")]),n._v(" "),t("blockquote",{staticClass:"wp-block-quote"},[n._v("工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。")]),n._v(" "),t("p",[n._v("简单说：假如我们想在网页面里插入一些元素，而这些元素类型不固定，可能是图片、链接、文本，根据工厂模式的定义，在工厂模式下，工厂函数只需接受我们要创建的元素的类型，其他的工厂函数帮我们处理。\n")]),n._v(" "),t("pre",{staticClass:"wp-block-code"},[t("code",[n._v("// 文本工厂\nclass Text {\n    constructor(text) {\n        this.text = text\n    }\n    insert(where) {\n        const txt = document.createTextNode(this.text)\n        where.appendChild(txt)\n    }\n}\n\n// 链接工厂\nclass Link {\n    constructor(url) {\n        this.url = url\n    }\n    insert(where) {\n        const link = document.createElement('a')\n        link.href = this.url\n        link.appendChild(document.createTextNode(this.url))\n        where.appendChild(link)\n    }\n}\n\n// 图片工厂\nclass Image {\n    constructor(url) {\n        this.url = url\n    }\n    insert(where) {\n        const img = document.createElement('img')\n        img.src = this.url\n        where.appendChild(img)\n    }\n}\n\n// DOM工厂\nclass DomFactory {\n\n  constructor(type) {\n    return new (this[type]())\n  }\n\n  // 各流水线\n  link() { return Link }\n  text() { return Text }\n  image() { return Image }\n}\n\n// 创建工厂\nconst linkFactory = new DomFactory('link')\nconst textFactory = new DomFactory('text')\n\nlinkFactory.url = 'https://surmon.me'\nlinkFactory.insert(document.body)\n\ntextFactory.text = 'HI! I am surmon.'\ntextFactory.insert(document.body)")])]),n._v(" "),t("h3",{attrs:{id:"articleHeader6"}},[n._v("装饰者模式 Decorative Pattern:")]),n._v(" "),t("blockquote",{staticClass:"wp-block-quote"},[n._v("装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责（方法或属性）。与继承相比，装饰者是一种更轻便灵活的做法。")]),n._v(" "),t("p",[n._v("简单说：可以动态的给某个对象添加额外的职责，而不会影响从这个类中派生的其它对象。\n")]),n._v(" "),t("pre",{staticClass:"wp-block-code"},[t("code",[n._v('ES7装饰器\nfunction isAnimal(target) {\n    target.isAnimal = true\n    return target\n}\n\n// 装饰器\n@isAnimal\nclass Cat {\n    // ...\n}\nconsole.log(Cat.isAnimal)    // true\n\n\n\n作用于类属性的装饰器：\n\nfunction readonly(target, name, descriptor) {\n    discriptor.writable = false\n    return discriptor\n}\n\nclass Cat {\n    @readonly\n    say() {\n        console.log("meow ~")\n    }\n}\n\nvar kitty = new Cat()\nkitty.say = function() {\n    console.log("woof !")\n}\nkitty.say()    // meow ~')])])])}),[],!1,null,null,null);e.default=a.exports}}]);